function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const assert = require('assert');

const fs = require('fs');

const path = require('path');

module.exports = (filepath, options = {}) => {
  assert(typeof filepath === 'string');
  assert(options instanceof Object && !Array.isArray(options));

  const ctx = _objectSpread({
    exclude: []
  }, options);

  assert(Object.keys(ctx).length === 1, 'Unexpected Option provided!');
  assert(Array.isArray(ctx.exclude));
  const dirname = path.dirname(filepath);
  const basename = path.basename(filepath);

  if (!fs.existsSync(dirname) || !fs.lstatSync(dirname).isDirectory()) {
    return null;
  }

  const relevantFiles = fs.readdirSync(dirname).filter(f => f === basename || f.startsWith(`${basename}.`) && f.lastIndexOf('.') <= basename.length).filter(f => !ctx.exclude.includes(f.slice(f.lastIndexOf('.') + 1)));

  if (relevantFiles.includes(basename)) {
    return filepath;
  }

  if (relevantFiles.length === 1) {
    return path.join(dirname, relevantFiles[0]);
  }

  return null;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sb2dpYy9ndWVzcy1maWxlLmpzIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJmcyIsInBhdGgiLCJtb2R1bGUiLCJleHBvcnRzIiwiZmlsZXBhdGgiLCJvcHRpb25zIiwiT2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwiY3R4IiwiZXhjbHVkZSIsImtleXMiLCJsZW5ndGgiLCJkaXJuYW1lIiwiYmFzZW5hbWUiLCJleGlzdHNTeW5jIiwibHN0YXRTeW5jIiwiaXNEaXJlY3RvcnkiLCJyZWxldmFudEZpbGVzIiwicmVhZGRpclN5bmMiLCJmaWx0ZXIiLCJmIiwic3RhcnRzV2l0aCIsImxhc3RJbmRleE9mIiwiaW5jbHVkZXMiLCJzbGljZSIsImpvaW4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQU1BLE1BQU0sR0FBR0MsT0FBTyxDQUFDLFFBQUQsQ0FBdEI7O0FBQ0EsTUFBTUMsRUFBRSxHQUFHRCxPQUFPLENBQUMsSUFBRCxDQUFsQjs7QUFDQSxNQUFNRSxJQUFJLEdBQUdGLE9BQU8sQ0FBQyxNQUFELENBQXBCOztBQUVBRyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsQ0FBQ0MsUUFBRCxFQUFXQyxPQUFPLEdBQUcsRUFBckIsS0FBNEI7QUFDM0NQLEVBQUFBLE1BQU0sQ0FBQyxPQUFPTSxRQUFQLEtBQW9CLFFBQXJCLENBQU47QUFDQU4sRUFBQUEsTUFBTSxDQUFDTyxPQUFPLFlBQVlDLE1BQW5CLElBQTZCLENBQUNDLEtBQUssQ0FBQ0MsT0FBTixDQUFjSCxPQUFkLENBQS9CLENBQU47O0FBRUEsUUFBTUksR0FBRztBQUNQQyxJQUFBQSxPQUFPLEVBQUU7QUFERixLQUVKTCxPQUZJLENBQVQ7O0FBSUFQLEVBQUFBLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDSyxJQUFQLENBQVlGLEdBQVosRUFBaUJHLE1BQWpCLEtBQTRCLENBQTdCLEVBQWdDLDZCQUFoQyxDQUFOO0FBQ0FkLEVBQUFBLE1BQU0sQ0FBQ1MsS0FBSyxDQUFDQyxPQUFOLENBQWNDLEdBQUcsQ0FBQ0MsT0FBbEIsQ0FBRCxDQUFOO0FBRUEsUUFBTUcsT0FBTyxHQUFHWixJQUFJLENBQUNZLE9BQUwsQ0FBYVQsUUFBYixDQUFoQjtBQUNBLFFBQU1VLFFBQVEsR0FBR2IsSUFBSSxDQUFDYSxRQUFMLENBQWNWLFFBQWQsQ0FBakI7O0FBQ0EsTUFBSSxDQUFDSixFQUFFLENBQUNlLFVBQUgsQ0FBY0YsT0FBZCxDQUFELElBQTJCLENBQUNiLEVBQUUsQ0FBQ2dCLFNBQUgsQ0FBYUgsT0FBYixFQUFzQkksV0FBdEIsRUFBaEMsRUFBcUU7QUFDbkUsV0FBTyxJQUFQO0FBQ0Q7O0FBQ0QsUUFBTUMsYUFBYSxHQUFHbEIsRUFBRSxDQUNyQm1CLFdBRG1CLENBQ1BOLE9BRE8sRUFFbkJPLE1BRm1CLENBRVhDLENBQUQsSUFBT0EsQ0FBQyxLQUFLUCxRQUFOLElBQW1CTyxDQUFDLENBQUNDLFVBQUYsQ0FBYyxHQUFFUixRQUFTLEdBQXpCLEtBQWdDTyxDQUFDLENBQUNFLFdBQUYsQ0FBYyxHQUFkLEtBQXNCVCxRQUFRLENBQUNGLE1BRjdFLEVBR25CUSxNQUhtQixDQUdYQyxDQUFELElBQU8sQ0FBQ1osR0FBRyxDQUFDQyxPQUFKLENBQVljLFFBQVosQ0FBcUJILENBQUMsQ0FBQ0ksS0FBRixDQUFRSixDQUFDLENBQUNFLFdBQUYsQ0FBYyxHQUFkLElBQXFCLENBQTdCLENBQXJCLENBSEksQ0FBdEI7O0FBSUEsTUFBSUwsYUFBYSxDQUFDTSxRQUFkLENBQXVCVixRQUF2QixDQUFKLEVBQXNDO0FBQ3BDLFdBQU9WLFFBQVA7QUFDRDs7QUFDRCxNQUFJYyxhQUFhLENBQUNOLE1BQWQsS0FBeUIsQ0FBN0IsRUFBZ0M7QUFDOUIsV0FBT1gsSUFBSSxDQUFDeUIsSUFBTCxDQUFVYixPQUFWLEVBQW1CSyxhQUFhLENBQUMsQ0FBRCxDQUFoQyxDQUFQO0FBQ0Q7O0FBQ0QsU0FBTyxJQUFQO0FBQ0QsQ0EzQkQiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZpbGVwYXRoLCBvcHRpb25zID0ge30pID0+IHtcbiAgYXNzZXJ0KHR5cGVvZiBmaWxlcGF0aCA9PT0gJ3N0cmluZycpO1xuICBhc3NlcnQob3B0aW9ucyBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zKSk7XG5cbiAgY29uc3QgY3R4ID0ge1xuICAgIGV4Y2x1ZGU6IFtdLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgYXNzZXJ0KE9iamVjdC5rZXlzKGN0eCkubGVuZ3RoID09PSAxLCAnVW5leHBlY3RlZCBPcHRpb24gcHJvdmlkZWQhJyk7XG4gIGFzc2VydChBcnJheS5pc0FycmF5KGN0eC5leGNsdWRlKSk7XG5cbiAgY29uc3QgZGlybmFtZSA9IHBhdGguZGlybmFtZShmaWxlcGF0aCk7XG4gIGNvbnN0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlcGF0aCk7XG4gIGlmICghZnMuZXhpc3RzU3luYyhkaXJuYW1lKSB8fCAhZnMubHN0YXRTeW5jKGRpcm5hbWUpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCByZWxldmFudEZpbGVzID0gZnNcbiAgICAucmVhZGRpclN5bmMoZGlybmFtZSlcbiAgICAuZmlsdGVyKChmKSA9PiBmID09PSBiYXNlbmFtZSB8fCAoZi5zdGFydHNXaXRoKGAke2Jhc2VuYW1lfS5gKSAmJiBmLmxhc3RJbmRleE9mKCcuJykgPD0gYmFzZW5hbWUubGVuZ3RoKSlcbiAgICAuZmlsdGVyKChmKSA9PiAhY3R4LmV4Y2x1ZGUuaW5jbHVkZXMoZi5zbGljZShmLmxhc3RJbmRleE9mKCcuJykgKyAxKSkpO1xuICBpZiAocmVsZXZhbnRGaWxlcy5pbmNsdWRlcyhiYXNlbmFtZSkpIHtcbiAgICByZXR1cm4gZmlsZXBhdGg7XG4gIH1cbiAgaWYgKHJlbGV2YW50RmlsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHBhdGguam9pbihkaXJuYW1lLCByZWxldmFudEZpbGVzWzBdKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4iXX0=